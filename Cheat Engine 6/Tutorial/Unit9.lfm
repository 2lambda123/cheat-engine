object Form9: TForm9
  Left = 471
  Height = 250
  Top = 160
  Width = 703
  BorderStyle = bsDialog
  Caption = 'Step 8'
  ClientHeight = 250
  ClientWidth = 703
  Font.Height = -11
  Font.Name = 'MS Sans Serif'
  OnClose = FormClose
  OnCloseQuery = FormCloseQuery
  OnCreate = FormCreate
  Position = poOwnerFormCenter
  LCLVersion = '0.9.29'
  Visible = True
  object Label1: TLabel
    Left = 8
    Height = 14
    Top = 209
    Width = 19
    Caption = '100'
    ParentColor = False
  end
  object Label2: TLabel
    Left = 116
    Height = 14
    Top = 208
    Width = 7
    Caption = '3'
    ParentColor = False
    Visible = False
  end
  object SpeedButton1: TSpeedButton
    Left = 668
    Height = 20
    Top = 229
    Width = 30
    Caption = 'Skip'
    Flat = True
    NumGlyphs = 0
    OnClick = SpeedButton1Click
  end
  object Memo1: TMemo
    Left = 0
    Height = 185
    Top = 0
    Width = 703
    Align = alTop
    Color = clBtnFace
    Lines.Strings = (
      'This step will explain how to use multi-level pointers.'
      'In step 6 you had a simple level-1 pointer, with the first address found already being the real base address.'
      'This step however is a level-4 pointer. It has a pointer to a pointer to a pointer to a pointer to a pointer to the health.'
      ''
      'You basicly do the same as in step 6. Find out what accesses the value, look at the instruction and what probably is '
      'the base pointer value, and what is the offset, and already fill that in or write it down. But in this case the address '
      'you''ll find will also be a pointer. You just have to find out the pointer to that pointer exactly the same way as you did '
      'with the value. Find out what accesses that address you found, look at the assembler instruction, note the probable '
      'instruction and offset, and use that.'
      'and continue till you can''t get any further (usually when the base address is a static address, shown up as green)'
      ''
      'Click Change Value to let the tutorial access the health.'
      'If you think you''ve found the pointer path click Change Register. The pointers and value will then change and you''ll '
      'have 3 seconds to freeze the address to 5000'
      ''
      'Extra: This problem can also be solved using a auto assembler script, or using the pointer scanner'
      'Extra2: In some situations it is recommended to change ce''s codefinder settings to Access violations when '
      'encountering instructions like mov eax,[eax] since debugregisters show it AFTER it was changed, making it hard to '
      'find out the the value of the pointer'
      ''
      ''
      ''
      ''
      ''
      'Extra3: If you''re still reading. You might notice that when looking at the assembler instructions that the pointer is '
      'being read and filled out in the same codeblock (same routine, if you know assembler, look up till the start of the '
      'routine). This doesn''t always happen, but can be really useful in finding a '
      'pointer when debugging is troublesome'
    )
    ReadOnly = True
    ScrollBars = ssVertical
    TabOrder = 0
  end
  object Button2: TButton
    Left = 248
    Height = 25
    Top = 192
    Width = 75
    Caption = 'Next'
    Enabled = False
    OnClick = Button2Click
    TabOrder = 1
  end
  object Button1: TButton
    Left = 8
    Height = 23
    Top = 224
    Width = 100
    Caption = 'Change value'
    OnClick = Button1Click
    TabOrder = 2
  end
  object Button3: TButton
    Left = 112
    Height = 23
    Top = 224
    Width = 100
    Caption = 'Change pointer'
    OnClick = Button3Click
    TabOrder = 3
  end
end
